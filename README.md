<!-- omit in toc -->
Alternative Source Generator for Unity
======================================

Alternative Source Generator is built on the Unity native functions.

- ✅ Unity Package Manager Support
- ✅ No Complicated IDE Environment Setup
- ✅ No Additional Package Installation


As you already know, Roslyn's source generator is too sophisticated. This framework provides more simple, ease of use and good enough functions for source code generation.

- [Troubleshooting](#troubleshooting)


<p><details lang="ja" --open><summary><small>日本語 / JA</small></summary>

超簡単に使える Unity 向けソースジェネレーターです。

<!------- End of Details JA Tag -------></details></p>


<p><details lang="en" --open><summary>Table of Contents</summary>

- [Sample Code](#sample-code)
    - [Method Generator](#method-generator)
        - [How to Use](#how-to-use)
        - [Result](#result)
    - [Generic Generator](#generic-generator)
        - [Result](#result-1)
- [Output Directory and File Name](#output-directory-and-file-name)
- [Coding Goodies](#coding-goodies)
- [Utility Functions for Build](#utility-functions-for-build)
- [Technical Notes](#technical-notes)
    - [Naming Convention](#naming-convention)
    - [`<auto-generated/>` Tag](#auto-generated-tag)
- [Installation](#installation)
- [Editor Extensions](#editor-extensions)
- [Troubleshooting](#troubleshooting)
- [Copyright](#copyright)
- [License](#license)
- [Devnote](#devnote)
    - [TODO](#todo)
    - [Memo](#memo)

<!------- End of Details EN Tag -------></details></p>





Sample Code
===========

Minimal implementation codes of source generator.

<p><details lang="ja" --open><summary><small>日本語 / JA</small></summary>

最小限のソースジェネレーターの構成はこちら。`StringBuilder` が渡されるので書き込んで `true` を返せば `context.OutputPath` に内容を書き込みます。`false` を返せば書き込みを中止できます。

<!------- End of Details JA Tag -------></details></p>


## Method Generator

This example will add `Pacic()` method to target class.

<p><details lang="ja" --open><summary><small>日本語 / JA</small></summary>

ターゲットのクラスに `Panic()` メソッドを追加するサンプル。

<!------- End of Details JA Tag -------></details></p>


```csharp
public class PanicMethodGenerator
{
    static string OutputFileName() => "PanicMethod.cs";  // -> PanicMethod.<TargetClass>.<GeneratorClass>.g.cs

    static bool Emit(USGContext context, StringBuilder sb)
    {
        if (!context.TargetClass.IsClass || context.TargetClass.IsAbstract)
            return false;  // return false to tell USG doesn't write file.

        // code generation
        sb.Append($@"
namespace {context.TargetClass.Namespace}
{{
    internal partial class {context.TargetClass.Name}
    {{
        public void Panic() => throw new System.Exception();
    }}
}}
");
        return true;
    }
}
```



### How to Use


```csharp
using SatorImaging.UnitySourceGenerator;

namespace Sample
{
    // Add attribute to target class to use method generator.
    // Note that class must be defined as partial class.
    [UnitySourceGenerator(typeof(PanicMethodGenerator), OverwriteIfFileExists = false)]
    internal partial class MethodGeneratorSample
    {
    }

}
```

### Result

Generated code looks like this.

```csharp
// <auto-generated>PanicMethodGenerator</auto-generated>

namespace Sample
{
    internal partial class MethodGeneratorSample
    {
        public void Panic() => throw new System.Exception();
    }
}
```



## Generic Generator

Here is target-less generator example.

It is useful to generate static database that cannot be generated on Unity runtime. For example, build asset GUIDs database using `UnityEditor.AssetDatabase`, resource integrity tables, etc.




```csharp
using System.Text;
using SatorImaging.UnitySourceGenerator;

[UnitySourceGenerator(OverwriteIfFileExists = false)]
class MinimalGenerator
{
    static string OutputFileName() => "Test.cs";  // -> Test.<ClassName>.g.cs

    static bool Emit(USGContext context, StringBuilder sb)
    {
        // write content into passed StringBuilder.
        sb.AppendLine($"Asset Path: {context.AssetPath}");
        sb.AppendLine($"Hello World from {typeof(MinimalGenerator)}");

        // you can modify output path. initial file name is that USG updated.
        // NOTE: USG doesn't care the modified path is valid or not.
        context.OutputPath += "_MyFirstTest.txt";

        // return true to tell USG to write content into OutputPath. false to do nothing.
        return true;
    }
}
```



### Result


```csharp
// <auto-generated>MinimalGenerator</auto-generated>
Asset Path: Assets/Scripts/MinimalGenerator.cs
Hello World from Sample.MinimalGenerator
```


Output Directory and File Name
==============================

Source Generator creates `USG.g` folder next to target script and append class names to file name.

Resulting file path will be:

- Assets/Scripts/<b>USG.g</b>/Test<b>.MinimalGenerator.g</b>.cs
- Assets/Scripts/<b>USG.g</b>/PanicMethod<b>.MethodGeneratorSample.PanicMethodGenerator.g</b>.cs

> NOTE: In above example, output path is modified so that resulting file name is `Test.MinimalGenerator.g.cs_MyFirstTest.txt`


<p><details lang="ja" --open><summary><small>日本語 / JA</small></summary>

書き出し先は上記の通り。フォルダーとターゲット・ジェネレータークラス名が付与されます。

<!------- End of Details JA Tag -------></details></p>



Coding Goodies
==============

There are utility methods for coding source generator more efficient and readable.

- `StringBuilder` Extentions
    - `IndentLine` / `IndentAppend`
    - `IndentLevel` / `IndentChar` / `IndentSize`
    - `IndentBegin` / `IndentEnd`
- `USGFullNameOf`
    - `usg`
- `USGReflection`
    - `GetAllPublicInstanceFieldAndProperty`
    - `TryGetFieldOrPropertyType`
    - `GetEnumNamesAndValuesAsDictionary`
    - `GetEnumNamesAndValuesAsTuple`

`usg` is a special utility that is designed for refactoring-ready source generator more readable, script template import it as a static library by default.


<p><details lang="ja" --open><summary><small>日本語 / JA</small></summary>

`System.Reflection` 系のユーティリティーと `StringBuilder` の拡張メソッド群。

`usg` は特殊で、クラス名やら何やらのリファクタリングに強いジェネレーターにすると読みづらくなってしまうのを緩和するためのモノ。

`{typeof(MyClass).FullName}.{nameof(MyClass.Property)}` どんどん長くなるだけなら良いけどクラス内クラスとか構造体の名前が + 付きの不正な状態で出てくる。その他にもジェネリッククラスへの対応とかなんとか、結局何かが必要になる。それならばと可能な限り短く書けるようにした。

インデント系はトリッキーだけど開発機での実行なのでまあ良し。

<!------- End of Details JA Tag -------></details></p>


```csharp
using static SatorImaging.UnitySourceGenerator.USGFullNameOf;  // usg<T>() to work

// simple usage -> Full.Namespace.To.MyClass.MyStruct.MyField
usg<MyClass>("MyStruct.MyField");
// most strict refactoring-ready coding is...
usg<MyClass>(nameof(MyClass.MyStruct), nameof(MyClass.MyStruct.MyField));

// indent utility
sb.IndentChar(' ');  // default
sb.IndentSize(4);    // default
sb.IndentLevel(3);   // template default
sb.IndentBegin();
{
    // cast int value to enum
    sb.IndentLine($"MyObject.EnumValue = ({usg<MyEnum>()})intValue");
    // --- or ---
    string CAST_MY_ENUM = "(" + usg(typeVariableCanBePassed) + ")";
    sb.IndentLine($"MyObject.EnumValue = {CAST_MY_ENUM}intValue");
}
sb.IndentEnd();
```

> **NOTE**: Inner class, enum or struct (`MyClass+InnerEnum`) is supported. Generic class (<code>MyClass`1</code>) naming is not supported yet.  



Utility Functions for Build
===========================

There are utility functions to perform source code generation on build event.

<p><details lang="ja" --open><summary><small>日本語 / JA</small></summary>

`IPostprocessBuildWithReport` も実装しようかと思ったものの、ビルドイベントに勝手に処理追加するのはなんか訳わからんが動かんの原因だし、BuildReport として渡される全てのファイル名を走査する処理は効率も良くない。ということで。

<!------- End of Details JA Tag -------></details></p>


```csharp
// perform code generation by class name if you don't know where it is.
USGUtility.ForceGenerateByName(nameof(MinimalGenerator));

// perform code generation by known path.
USGEngine.IgnoreOverwriteSettingByAttribute = true;  // force overwrite
USGEngine.ProcessFile(assetPath);
```



Technical Notes
===============

As of C# 9.0, it doesn't allow to define `abstract static` methods in interface, USG reports error when source generator class doesn't implement required static methods.

<p><details lang="ja" --open><summary><small>日本語 / JA</small></summary>

理想はアトリビュートとインターフェイスによるフィルタリングですが、Unity 2021 は C# 9.0 で `abstract static` を含んだインターフェイスが使えません。

しょうがないのでメソッドのシグネチャを確認して存在しなければエラーをコンソールに出します。

<!------- End of Details JA Tag -------></details></p>


![](https://dl.dropbox.com/s/kstbafbnyc54k2l/USG_IntefaceError.jpg)



## Naming Convention

- Generator class name and filename must be matched.
- Class name must be unique in whole project.
- Classes are ignored if defined in assembly which name starts with:
    - `Unity` (no trailing dot)
    - `System.`
    - `Mono.`


<p><details lang="ja" --open><summary><small>日本語 / JA</small></summary>

- ジェネレータークラスの名前はファイル名と一致
- ジェネレータクラスの名前はプロジェクト内で一意
- クラスが以下で始まる名前のアセンブリで宣言されている場合は対象としない
    - `Unity` (末尾ドット無し)
    - `System.`
    - `Mono.`

<!------- End of Details JA Tag -------></details></p>



## `<auto-generated/>` Tag

USG automatically adds document tag at the beginning of generated file. You can remove this document tag by `sb.Clear()` in `Emit()` method.


<p><details lang="ja" --open><summary><small>日本語 / JA</small></summary>

渡される `StringBuilder` の冒頭にはドキュメントタグが入ってます。不要なら `sb.Clear()` してください。

<!------- End of Details JA Tag -------></details></p>



Installation
============

Use the following git URL in Unity Package Manager (UPM).

- Latest: https://github.com/sator-imaging/Unity-AltSourceGenerator.git
- v1.0.0: https://github.com/sator-imaging/Unity-AltSourceGenerator.git#v1.0.0



Editor Extensions
=================

<p><details lang="ja" --open><summary><small>日本語 / JA</small></summary>

手動でソースコード生成イベントの発火も可能です。「ジェネレーターのスクリプトファイル」か「生成されたファイル」を選択して、Project ウインドウで `Reimport` か `Unity Source Generator` 以下のメニューを実行します。

ジェネレーターとして参照されているファイルを Reimport した場合は、関連するクラスすべてが再生成されます。`Force Generate...` はクラスアトリビュートの設定に関わらず強制的に上書き生成します。

<!------- End of Details JA Tag -------></details></p>

There is an ability to invoke source code generation by hand. With generator script file or generated file selected in Project window:

- `Reimport`
    - This command respects `OverwriteIfFileExists` setting by generator class attribute.
    - Classes referencing selected generator will also be re-generated.

- `Unity Source Generator > Force Generate`
    - This command will force re-generate source code even if overwrite setting is disabled.


![](https://dl.dropbox.com/s/skqa6mwh932lsrg/USG_FireEvent.jpg)



Troubleshooting
===============

#### Generator script update is not applied to generated file.

Usually, this problem happens when Unity automatically reloads updated scripts WITHOUT Editor window getting focus. To solve the problem:

1. Close Unity and Visual Studio.
1. Restart Unity.
1. Launch Visual Studio by double clicking `.cs` script in Unity Editor.





Copyright
=========

Copyright &copy; 2023 Sator Imaging, all rights reserved.



License
=======

<p>
<details>
<summary>The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.</summary>

```text
MIT License

Copyright (c) 2023 Sator Imaging

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

</details>
</p>





&nbsp;  
&nbsp;

# Devnote


## TODO

- Add new attribute option `UseCustomWriter` to use it's own file writer instead of builtin writer. For the "non-allocation" addicted developers.
    - `USGEngine.ProcessingFile()` doesn't care what happens in custom writer. just returns true in this situation.
    - Option is for generator class. Referenced generator class doesn't have `UnitySourceGenerator` attribute so that need to retrieve it from target classes. (how handle conflicts?)
    - `USGContext.UseCustomWriter` can be used to prevent writing file but `StringBuilder` is built prior to `Emit()` method.



## Memo

Unity doesn't invoke import event if Visual Studio is not launch by current session of Unity...?
